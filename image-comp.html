<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Screenshot Color Sampler</title>
    <style>
      :root {
        --gap: 1rem;
      }
      body {
        font-family: sans-serif;
        margin: var(--gap);
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--gap);
      }
      .canvas-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
        position: relative;
      }
      canvas {
        border: 1px solid #ccc;
        width: 100%;
        max-width: 100%;
        cursor: crosshair;
        box-sizing: border-box;
      }
      .controls {
        grid-column: span 2;
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      .table-wrapper {
        grid-column: span 2;
        overflow-x: auto;
      }
      table {
        border-collapse: collapse;
        width: 100%;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 0.5rem;
        text-align: center;
      }
      #dropZone {
        grid-column: span 2;
        border: 2px dashed #999;
        padding: 1rem;
        text-align: center;
        margin-bottom: 1rem;
        user-select: none;
      }
      .active-label {
        font-size: 0.85rem;
      }
      .canvas-container {
        position: relative;
        display: inline-block;
      }
      .svg-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 10;
      }
      .draggable-dot {
        cursor: move;
        pointer-events: all;
      }
      .dot-label {
        font-family: Arial, sans-serif;
        font-size: 12px;
        font-weight: bold;
        fill: white;
        text-anchor: middle;
        dominant-baseline: central;
        pointer-events: none;
      }
      .remove-btn {
        background: #ff4444;
        color: white;
        border: none;
        padding: 2px 6px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 3px;
      }
      .remove-btn:hover {
        background: #cc0000;
      }
      .color-swatch {
        width: 30px;
        height: 30px;
        display: inline-block;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .preview-canvas {
        width: 50px;
        height: 50px;
        border: 1px solid #ddd;
        image-rendering: pixelated;
      }
      .coord-input {
        width: 50px;
        padding: 2px;
        text-align: center;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .sync-btn {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 12px;
        border-radius: 3px;
      }
      .sync-btn:hover {
        background: #45a049;
      }
      .color-cell {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 150px;
      }
      .color-info {
        display: flex;
        flex-direction: column;
        line-height: 1.2;
      }
      .hex-value {
        font-weight: bold;
        font-size: 12px;
      }
      .hsl-value {
        font-size: 11px;
        color: #666;
      }
      .coord-cell {
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 60px;
      }
      .coord-cell input {
        width: 50px;
        margin: 0;
      }
      .sync-cell {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .sync-cell button {
        padding: 2px 4px;
        font-size: 10px;
        width: 60px;
      }
      .sync-before {
        background: #2196F3;
      }
      .sync-before:hover {
        background: #1976D2;
      }
      .sync-after {
        background: #FF9800;
      }
      .sync-after:hover {
        background: #F57C00;
      }
    </style>
  </head>
  <body>
    <div id="dropZone">
      Drop <strong>or paste</strong> two images here (1st = BEFORE, 2nd =
      AFTER). Active target is highlighted.
    </div>
    <input type="file" id="file1" accept="image/*" style="display: none" />
    <input type="file" id="file2" accept="image/*" style="display: none" />

    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb1" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas1"></canvas>
        <svg class="svg-overlay" id="svg1"></svg>
      </div>
      <button onclick="document.getElementById('file1').click();">
        Choose Image 1
      </button>
    </div>
    <div class="canvas-wrapper">
      <label class="active-label"
        ><input type="checkbox" id="cb2" /> Active</label
      >
      <div class="canvas-container">
        <canvas id="canvas2"></canvas>
        <svg class="svg-overlay" id="svg2"></svg>
      </div>
      <button onclick="document.getElementById('file2').click();">
        Choose Image 2
      </button>
    </div>

    <div class="controls">
      <button id="clearBtn">Clear Points</button>
      <button id="randomBtn">Sample 10 Random Points</button>
    </div>
    <div class="table-wrapper">
      <table id="results">
        <thead>
          <tr>
            <th>#</th>
            <th>Color (Before)</th>
            <th>Color (After)</th>
            <th>Preview Before</th>
            <th>Preview After</th>
            <th>Coords Before</th>
            <th>Coords After</th>
            <th>Sync</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      const canvases = [
        document.getElementById("canvas1"),
        document.getElementById("canvas2"),
      ];
      const svgs = [
        document.getElementById("svg1"),
        document.getElementById("svg2"),
      ];
      const files = [
        document.getElementById("file1"),
        document.getElementById("file2"),
      ];
      const checkboxes = [
        document.getElementById("cb1"),
        document.getElementById("cb2"),
      ];
      let images = [null, null];
      let activeIndex = 0; // 0 => before, 1 => after
      let points = [];
      let pointIdCounter = 1;
      let draggedPoint = null;
      
      // Persistence functions
      function saveToStorage() {
        const data = {
          points: points,
          pointIdCounter: pointIdCounter,
          images: images.map((img, index) => {
            if (!img) return null;
            // Convert canvas to base64 data URL for persistence
            const canvas = canvases[index];
            return canvas.toDataURL('image/png');
          })
        };
        localStorage.setItem('colorSamplerData', JSON.stringify(data));
      }
      
      function loadFromStorage() {
        const stored = localStorage.getItem('colorSamplerData');
        if (!stored) return;
        
        try {
          const data = JSON.parse(stored);
          pointIdCounter = data.pointIdCounter || 1;
          
          // Load images
          if (data.images) {
            let loadedCount = 0;
            const totalImages = data.images.filter(src => src).length;
            
            data.images.forEach((src, index) => {
              if (src) {
                const img = new Image();
                img.onload = () => {
                  drawImageToCanvas(img, canvases[index]);
                  images[index] = img;
                  loadedCount++;
                  
                  // After all images are loaded, restore points
                  if (loadedCount === totalImages && data.points) {
                    restorePoints(data.points);
                  }
                };
                img.onerror = () => {
                  console.error('Error loading image from storage for index:', index);
                };
                img.src = src;
              }
            });
          }
        } catch (e) {
          console.error('Error loading from storage:', e);
        }
      }
      
      function restorePoints(savedPoints) {
        points = savedPoints;
        
        // Clear existing table and SVG
        tbody.innerHTML = '';
        svgs.forEach(svg => svg.innerHTML = '');
        
        // Recreate points
        points.forEach(point => {
          // Add dots to both SVG overlays
          svgs.forEach(svg => {
            createSVGDot(svg, point.x1, point.y1, point.id);
          });
          
          // Get colors and add to table
          const c1 = getColorAt(canvases[0], point.x1, point.y1);
          const c2 = getColorAt(canvases[1], point.x2, point.y2);
          addRow(
            point.id,
            hex(c1[0], c1[1], c1[2]),
            hex(c2[0], c2[1], c2[2]),
            rgbToHsl(c1[0], c1[1], c1[2]),
            rgbToHsl(c2[0], c2[1], c2[2]),
            point.x1, point.y1, point.x2, point.y2
          );
          
          // No need to set sync state for buttons
        });
      }
      
      checkboxes[0].checked = true;
      checkboxes.forEach((cb, i) =>
        cb.addEventListener("change", () => {
          if (cb.checked) {
            activeIndex = i;
            checkboxes[1 - i].checked = false;
          }
        })
      );
      function loadFile(file, index) {
        if (!file) return;
        const img = new Image();
        img.onload = () => {
          drawImageToCanvas(img, canvases[index]);
          images[index] = img;
          saveToStorage();
        };
        img.src = URL.createObjectURL(file);
      }
      files.forEach(
        (input, idx) =>
          (input.onchange = (e) => loadFile(e.target.files[0], idx))
      );
      function drawImageToCanvas(img, canvas) {
        const ratio = img.width / img.height;
        const maxWidth = 800;
        const width = Math.min(img.width, maxWidth);
        const height = width / ratio;
        canvas.width = width;
        canvas.height = height;
        canvas.getContext("2d").drawImage(img, 0, 0, width, height);
        
        // Update SVG overlay size
        const svgIndex = canvases.indexOf(canvas);
        if (svgIndex !== -1) {
          const svg = svgs[svgIndex];
          svg.setAttribute('width', width);
          svg.setAttribute('height', height);
          
          // Update dot positions after canvas resize
          setTimeout(updateAllDotPositions, 50);
        }
      }
      function hex(r, g, b) {
        return (
          "#" +
          [r, g, b]
            .map((v) => v.toString(16).padStart(2, "0"))
            .join("")
            .toUpperCase()
        );
      }
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return `hsl(${Math.round(h * 360)}, ${Math.round(
          s * 100
        )}%, ${Math.round(l * 100)}%)`;
      }
      const tbody = document.querySelector("#results tbody");
      
      function addRow(pointId, hex1, hex2, hsl1, hsl2, x1, y1, x2, y2) {
        const tr = document.createElement("tr");
        tr.setAttribute('data-point-id', pointId);
        
        // Create color cells with swatch and text
        const colorCell1 = `
          <div class="color-cell">
            <div class="color-swatch" style="background-color: ${hex1}"></div>
            <div class="color-info">
              <div class="hex-value">${hex1}</div>
              <div class="hsl-value">${hsl1}</div>
            </div>
          </div>
        `;
        
        const colorCell2 = `
          <div class="color-cell">
            <div class="color-swatch" style="background-color: ${hex2}"></div>
            <div class="color-info">
              <div class="hex-value">${hex2}</div>
              <div class="hsl-value">${hsl2}</div>
            </div>
          </div>
        `;
        
        // Create coordinate cells
        const coordCell1 = `
          <div class="coord-cell">
            <input type="number" class="coord-input" value="${Math.round(x1)}" onchange="updatePointCoord(${pointId}, 'x1', this.value)" placeholder="X">
            <input type="number" class="coord-input" value="${Math.round(y1)}" onchange="updatePointCoord(${pointId}, 'y1', this.value)" placeholder="Y">
          </div>
        `;
        
        const coordCell2 = `
          <div class="coord-cell">
            <input type="number" class="coord-input" value="${Math.round(x2)}" onchange="updatePointCoord(${pointId}, 'x2', this.value)" placeholder="X">
            <input type="number" class="coord-input" value="${Math.round(y2)}" onchange="updatePointCoord(${pointId}, 'y2', this.value)" placeholder="Y">
          </div>
        `;
        
        // Create sync buttons (will be conditionally shown)
        const syncButtons = createSyncButtons(pointId, x1, y1, x2, y2);
        
        // Create preview canvases
        const preview1 = createPreviewCanvas(0, x1, y1);
        const preview2 = createPreviewCanvas(1, x2, y2);
        
        // Create cells with innerHTML for most content
        tr.innerHTML = `
          <td>${pointId}</td>
          <td>${colorCell1}</td>
          <td>${colorCell2}</td>
          <td></td>
          <td></td>
          <td>${coordCell1}</td>
          <td>${coordCell2}</td>
          <td><div class="sync-cell">${syncButtons}</div></td>
          <td><button class="remove-btn" onclick="removePoint(${pointId})">Remove</button></td>
        `;
        
        // Insert the actual canvas elements into the preview cells
        const cells = tr.getElementsByTagName('td');
        cells[3].appendChild(preview1);
        cells[4].appendChild(preview2);
        
        tbody.appendChild(tr);
        saveToStorage();
      }
      
      function removePoint(pointId) {
        // Remove from points array
        points = points.filter(p => p.id !== pointId);
        
        // Remove from table
        const row = document.querySelector(`tr[data-point-id="${pointId}"]`);
        if (row) row.remove();
        
        // Remove from SVG overlays
        svgs.forEach(svg => {
          const dotGroup = svg.querySelector(`g[data-point-id="${pointId}"]`);
          if (dotGroup) dotGroup.remove();
        });
        
        saveToStorage();
      }
      function getColorAt(canvas, x, y) {
        return canvas.getContext("2d").getImageData(x, y, 1, 1).data;
      }
      function getDisplayCoordinates(canvas, canvasX, canvasY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = rect.width / canvas.width;
        const scaleY = rect.height / canvas.height;
        
        return {
          x: canvasX * scaleX,
          y: canvasY * scaleY
        };
      }
      
      function createSVGDot(svg, x, y, pointId) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('data-point-id', pointId);
        g.setAttribute('class', 'draggable-dot');
        
        // Get the canvas associated with this SVG
        const svgIndex = svgs.indexOf(svg);
        const canvas = canvases[svgIndex];
        const displayCoords = getDisplayCoordinates(canvas, x, y);
        
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', displayCoords.x);
        circle.setAttribute('cy', displayCoords.y);
        circle.setAttribute('r', '8');
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', 'red');
        circle.setAttribute('stroke-width', '3');
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', displayCoords.x);
        text.setAttribute('y', displayCoords.y);
        text.setAttribute('class', 'dot-label');
        text.textContent = pointId;
        
        g.appendChild(circle);
        g.appendChild(text);
        svg.appendChild(g);
        
        // Add drag functionality
        addDragBehavior(g, circle, text, pointId);
        
        return g;
      }
      
      function addDragBehavior(group, circle, text, pointId) {
        let isDragging = false;
        let startX, startY;
        
        group.addEventListener('mousedown', (e) => {
          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          draggedPoint = pointId;
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging || draggedPoint !== pointId) return;
          
          const svg = group.parentNode;
          const svgIndex = svgs.indexOf(svg);
          const canvas = canvases[svgIndex];
          
          // Get scaled coordinates relative to the canvas
          const coords = getScaledCoordinates(canvas, e.clientX, e.clientY);
          const newX = coords.x;
          const newY = coords.y;
          
          // Convert canvas coordinates to display coordinates for SVG
          const displayCoords = getDisplayCoordinates(canvas, newX, newY);
          circle.setAttribute('cx', displayCoords.x);
          circle.setAttribute('cy', displayCoords.y);
          text.setAttribute('x', displayCoords.x);
          text.setAttribute('y', displayCoords.y);
          
          // Update point in array
          const point = points.find(p => p.id === pointId);
          if (point) {
            if (svgIndex === 0) {
              point.x1 = newX;
              point.y1 = newY;
              
            } else {
              point.x2 = newX;
              point.y2 = newY;
              
            }
            updatePointColors(point);
          }
          
          startX = e.clientX;
          startY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
          draggedPoint = null;
          saveToStorage();
        });
      }
      
      function updatePointColors(point) {
        const c1 = getColorAt(canvases[0], point.x1, point.y1);
        const c2 = getColorAt(canvases[1], point.x2, point.y2);
        
        const row = document.querySelector(`tr[data-point-id="${point.id}"]`);
        if (row) {
          const cells = row.getElementsByTagName('td');
          const hex1 = hex(c1[0], c1[1], c1[2]);
          const hex2 = hex(c2[0], c2[1], c2[2]);
          const hsl1 = rgbToHsl(c1[0], c1[1], c1[2]);
          const hsl2 = rgbToHsl(c2[0], c2[1], c2[2]);
          
          // Update color cells
          cells[1].innerHTML = `
            <div class="color-cell">
              <div class="color-swatch" style="background-color: ${hex1}"></div>
              <div class="color-info">
                <div class="hex-value">${hex1}</div>
                <div class="hsl-value">${hsl1}</div>
              </div>
            </div>
          `;
          
          cells[2].innerHTML = `
            <div class="color-cell">
              <div class="color-swatch" style="background-color: ${hex2}"></div>
              <div class="color-info">
                <div class="hex-value">${hex2}</div>
                <div class="hsl-value">${hsl2}</div>
              </div>
            </div>
          `;
          
          // Update previews
          cells[3].innerHTML = '';
          cells[4].innerHTML = '';
          cells[3].appendChild(createPreviewCanvas(0, point.x1, point.y1));
          cells[4].appendChild(createPreviewCanvas(1, point.x2, point.y2));
          
          // Update coordinates
          const coordInputs1 = cells[5].querySelectorAll('input');
          const coordInputs2 = cells[6].querySelectorAll('input');
          coordInputs1[0].value = Math.round(point.x1);
          coordInputs1[1].value = Math.round(point.y1);
          coordInputs2[0].value = Math.round(point.x2);
          coordInputs2[1].value = Math.round(point.y2);
          
          // Update sync buttons
          const syncButtons = createSyncButtons(point.id, point.x1, point.y1, point.x2, point.y2);
          cells[7].innerHTML = `<div class="sync-cell">${syncButtons}</div>`;
        }
      }
      
      function getScaledCoordinates(canvas, clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        return {
          x: Math.round((clientX - rect.left) * scaleX),
          y: Math.round((clientY - rect.top) * scaleY)
        };
      }
      
      function clickHandler(e) {
        if (!images[0] || !images[1]) return;
        const coords = getScaledCoordinates(this, e.clientX, e.clientY);
        const x = coords.x;
        const y = coords.y;
        
        // Create new point
        const pointId = pointIdCounter++;
        const point = {
          id: pointId,
          x1: x,
          y1: y,
          x2: x,
          y2: y
        };
        points.push(point);
        
        // Add dots to both SVG overlays
        svgs.forEach(svg => {
          createSVGDot(svg, x, y, pointId);
        });
        
        // Get colors and add to table
        const c1 = getColorAt(canvases[0], x, y);
        const c2 = getColorAt(canvases[1], x, y);
        addRow(
          pointId,
          hex(c1[0], c1[1], c1[2]),
          hex(c2[0], c2[1], c2[2]),
          rgbToHsl(c1[0], c1[1], c1[2]),
          rgbToHsl(c2[0], c2[1], c2[2]),
          x, y, x, y
        );
      }
      canvases.forEach((c) => c.addEventListener("click", clickHandler));
      document.getElementById("clearBtn").onclick = () => {
        tbody.innerHTML = "";
        points = [];
        pointIdCounter = 1;
        svgs.forEach(svg => {
          svg.innerHTML = '';
        });
        images.forEach((img, i) => {
          if (img) drawImageToCanvas(img, canvases[i]);
        });
        saveToStorage();
      };
      // Handle drag & drop
      const dropZone = document.getElementById("dropZone");
      ["dragenter", "dragover"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#333";
        })
      );
      ["dragleave", "drop"].forEach((evt) =>
        dropZone.addEventListener(evt, (e) => {
          e.preventDefault();
          dropZone.style.borderColor = "#999";
        })
      );
      dropZone.addEventListener("drop", (e) => {
        const filesArr = [...e.dataTransfer.files].filter((f) =>
          f.type.startsWith("image/")
        );
        filesArr.forEach((f) => {
          loadFile(f, activeIndex);
          toggleActive();
        });
      });
      // Handle paste
      function handlePaste(e) {
        const items = [...e.clipboardData.items];
        for (const item of items) {
          if (item.type.startsWith("image/")) {
            const file = item.getAsFile();
            loadFile(file, activeIndex);
            toggleActive();
            e.preventDefault();
            break;
          }
        }
      }
      function toggleActive() {
        activeIndex = 1 - activeIndex;
        checkboxes[activeIndex].checked = true;
        checkboxes[1 - activeIndex].checked = false;
      }
      
      function createPreviewCanvas(canvasIndex, x, y) {
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = 10;
        previewCanvas.height = 10;
        previewCanvas.className = 'preview-canvas';
        
        if (!images[canvasIndex]) {
          return previewCanvas;
        }
        
        const ctx = previewCanvas.getContext('2d');
        const sourceCanvas = canvases[canvasIndex];
        
        // Extract 10x10 pixel area centered on the point
        const startX = Math.max(0, Math.floor(x - 5));
        const startY = Math.max(0, Math.floor(y - 5));
        const width = Math.min(10, sourceCanvas.width - startX);
        const height = Math.min(10, sourceCanvas.height - startY);
        
        if (width > 0 && height > 0) {
          try {
            const imageData = sourceCanvas.getContext('2d').getImageData(startX, startY, width, height);
            ctx.putImageData(imageData, 0, 0);
          } catch (e) {
            console.error('Error creating preview:', e);
          }
        }
        
        return previewCanvas;
      }
      
      function updatePointCoord(pointId, coord, value) {
        const point = points.find(p => p.id === pointId);
        if (!point) return;
        
        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;
        
        point[coord] = numValue;
        
        // Update SVG dots
        const isFirstCanvas = coord === 'x1' || coord === 'y1';
        const svgIndex = isFirstCanvas ? 0 : 1;
        const svg = svgs[svgIndex];
        const canvas = canvases[svgIndex];
        const dotGroup = svg.querySelector(`g[data-point-id="${pointId}"]`);
        
        if (dotGroup) {
          const circle = dotGroup.querySelector('circle');
          const text = dotGroup.querySelector('text');
          
          if (coord.endsWith('1')) {
            const displayCoords = getDisplayCoordinates(canvas, point.x1, point.y1);
            circle.setAttribute('cx', displayCoords.x);
            circle.setAttribute('cy', displayCoords.y);
            text.setAttribute('x', displayCoords.x);
            text.setAttribute('y', displayCoords.y);
          } else {
            const displayCoords = getDisplayCoordinates(canvas, point.x2, point.y2);
            circle.setAttribute('cx', displayCoords.x);
            circle.setAttribute('cy', displayCoords.y);
            text.setAttribute('x', displayCoords.x);
            text.setAttribute('y', displayCoords.y);
          }
        }
        
        // Update colors and previews
        updatePointColors(point);
        saveToStorage();
      }
      
      function createSyncButtons(pointId, x1, y1, x2, y2) {
        const coordsMatch = (Math.round(x1) === Math.round(x2)) && (Math.round(y1) === Math.round(y2));
        
        if (coordsMatch) {
          return ''; // No sync buttons if coordinates match
        }
        
        return `
          <button class="sync-btn sync-before" onclick="syncAfterToBefore(${pointId})" title="Sync After to Before">→</button>
          <button class="sync-btn sync-after" onclick="syncBeforeToAfter(${pointId})" title="Sync Before to After">←</button>
        `;
      }
      
      function syncAfterToBefore(pointId) {
        const point = points.find(p => p.id === pointId);
        if (!point) return;
        
        // Force after coords to match before coords
        point.x2 = point.x1;
        point.y2 = point.y1;
        
        // Update the SVG dot on the second canvas
        const svg2 = svgs[1];
        const dotGroup = svg2.querySelector(`g[data-point-id="${pointId}"]`);
        if (dotGroup) {
          const circle = dotGroup.querySelector('circle');
          const text = dotGroup.querySelector('text');
          const displayCoords = getDisplayCoordinates(canvases[1], point.x2, point.y2);
          circle.setAttribute('cx', displayCoords.x);
          circle.setAttribute('cy', displayCoords.y);
          text.setAttribute('x', displayCoords.x);
          text.setAttribute('y', displayCoords.y);
        }
        
        // Update colors and previews
        updatePointColors(point);
        saveToStorage();
      }
      
      function syncBeforeToAfter(pointId) {
        const point = points.find(p => p.id === pointId);
        if (!point) return;
        
        // Force before coords to match after coords
        point.x1 = point.x2;
        point.y1 = point.y2;
        
        // Update the SVG dot on the first canvas
        const svg1 = svgs[0];
        const dotGroup = svg1.querySelector(`g[data-point-id="${pointId}"]`);
        if (dotGroup) {
          const circle = dotGroup.querySelector('circle');
          const text = dotGroup.querySelector('text');
          const displayCoords = getDisplayCoordinates(canvases[0], point.x1, point.y1);
          circle.setAttribute('cx', displayCoords.x);
          circle.setAttribute('cy', displayCoords.y);
          text.setAttribute('x', displayCoords.x);
          text.setAttribute('y', displayCoords.y);
        }
        
        // Update colors and previews
        updatePointColors(point);
        saveToStorage();
      }
      
      function sampleRandomPoints() {
        if (!images[0] || !images[1]) {
          alert('Please load both images first');
          return;
        }
        
        const width = canvases[0].width;
        const height = canvases[0].height;
        
        for (let i = 0; i < 10; i++) {
          const x = Math.floor(Math.random() * width);
          const y = Math.floor(Math.random() * height);
          
          // Create new point
          const pointId = pointIdCounter++;
          const point = {
            id: pointId,
            x1: x,
            y1: y,
            x2: x,
            y2: y
          };
          points.push(point);
          
          // Add dots to both SVG overlays
          svgs.forEach(svg => {
            createSVGDot(svg, x, y, pointId);
          });
          
          // Get colors and add to table
          const c1 = getColorAt(canvases[0], x, y);
          const c2 = getColorAt(canvases[1], x, y);
          addRow(
            pointId,
            hex(c1[0], c1[1], c1[2]),
            hex(c2[0], c2[1], c2[2]),
            rgbToHsl(c1[0], c1[1], c1[2]),
            rgbToHsl(c2[0], c2[1], c2[2]),
            x, y, x, y
          );
        }
      }
      
      document.addEventListener("paste", handlePaste);
      
      // Add event listener for random sampling button
      document.getElementById('randomBtn').addEventListener('click', sampleRandomPoints);
      
      // Function to update all SVG dot positions after resize
      function updateAllDotPositions() {
        points.forEach(point => {
          // Update dots on both canvases
          svgs.forEach((svg, svgIndex) => {
            const dotGroup = svg.querySelector(`g[data-point-id="${point.id}"]`);
            if (dotGroup) {
              const circle = dotGroup.querySelector('circle');
              const text = dotGroup.querySelector('text');
              const canvas = canvases[svgIndex];
              
              // Get the appropriate coordinates for this canvas
              const canvasX = svgIndex === 0 ? point.x1 : point.x2;
              const canvasY = svgIndex === 0 ? point.y1 : point.y2;
              
              // Convert to display coordinates
              const displayCoords = getDisplayCoordinates(canvas, canvasX, canvasY);
              
              // Update SVG elements
              circle.setAttribute('cx', displayCoords.x);
              circle.setAttribute('cy', displayCoords.y);
              text.setAttribute('x', displayCoords.x);
              text.setAttribute('y', displayCoords.y);
            }
          });
        });
      }
      
      // Initialize from storage on page load
      window.addEventListener('load', () => {
        loadFromStorage();
      });
      
      // Handle window resize to reposition SVG dots
      window.addEventListener('resize', () => {
        // Use a small delay to allow the DOM to update
        setTimeout(updateAllDotPositions, 100);
      });
    </script>
  </body>
</html>
